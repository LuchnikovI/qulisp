use std::str::FromStr;
use lalrpop_util::ParseError;
use crate::ast::{Atom, SExpr, QLispParseError, Symbol};

grammar;

extern {
    type Error = QLispParseError;
}

match {
    r"\(" => LPAREN,
    r"\)" => RPAREN,
    r"\." => DOT,
    r"[1-9]+[0-9]*|0" => INT,
    r"([0-9]+\.[0-9]*|[0-9]*\.[0-9]+)([eE][-+]?[0-9]+)?" => FLOAT,
    r#"\"[^\"]*\""# => STR,
    r"\s*" => { },
    r";[^\n\r]*[\n\r]*" => { },
} else {
    r"[^[:space:]\(\)]+" => ID,
}

Atom: Atom = {
    <l:@L><i:INT><r:@R> =>? Ok(Atom::Int(i64::from_str(i).map_err(
        |_| ParseError::User {
            error: QLispParseError::CannotParseInt(l, r)
        }
    )?)),
    <l:@L><f:FLOAT><r:@R> =>? Ok(Atom::Float(f64::from_str(f).map_err(
        |_| ParseError::User {
            error: QLispParseError::CannotParseFloat(l, r)
        }
    )?)),
    <s:STR> => Atom::String(s.trim_matches('\"').to_owned()),
    <id:ID> => Atom::Symbol(Symbol(id.to_owned())),
};

SExpr: SExpr = {
    <l:@L> LPAREN <s1:SExpr> DOT <s2:SExpr> RPAREN <r:@R> => SExpr::Pair(Box::new(s1), Box::new(s2), l , r),
    <l:@L> <atom:Atom> <r:@R> => SExpr::Atom(atom, l, r),
    <l:@L> LPAREN <sexprs:SExpr*> RPAREN <r:@R> => SExpr::List(sexprs.into_iter().collect::<Vec<_>>(), l, r),
}

pub Program: Vec<SExpr> = {
    <sexprs:SExpr*> => sexprs.into_iter().collect::<Vec<_>>(),
}
