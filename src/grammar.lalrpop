use std::rc::Rc;
use std::str::FromStr;
use lalrpop_util::ParseError;
use crate::ast::{Atom, SExpr, QLispParseError};

grammar;

extern {
    type Error = QLispParseError;
}

match {
    r"\(" => LPAREN,
    r"\)" => RPAREN,
    r"\." => DOT,
    r"[1-9]+[0-9]*|0" => INT,
    r"([0-9]+\.[0-9]*|[0-9]*\.[0-9]+)([eE][-+]?[0-9]+)?" => FLOAT,
    r#"\"[^\"]*\""# => STR,
    r"\s*" => { },
    r";[^\n\r]*[\n\r]*" => { },
    r"`" => QUOTE
} else {
    r"[^[:space:]\(\)]+" => ID,
}

Atom: Atom<'input> = {
    <l:@L><i:INT><r:@R> =>? Ok(Atom::Int(i64::from_str(i).map_err(
        |_| ParseError::User {
            error: QLispParseError::CannotParseInt(l, r)
        }
    )?)),
    <l:@L><f:FLOAT><r:@R> =>? Ok(Atom::Float(f64::from_str(f).map_err(
        |_| ParseError::User {
            error: QLispParseError::CannotParseFloat(l, r)
        }
    )?)),
    <s:STR> => Atom::String(s.trim_matches('\"').to_owned()),
    <id:ID> => Atom::Symbol(id),
};

SExpr: SExpr<'input> = {
    <l:@L> LPAREN <s1:SExpr> DOT <s2:SExpr> RPAREN <r:@R> => {
        SExpr::Pair(Rc::new(s1), Rc::new(s2), Some((l , r)))
    },
    <l:@L> <atom:Atom> <r:@R> => SExpr::Atom(atom, Some((l , r))),
    <l:@L> LPAREN <sexprs:SExpr*> RPAREN <r:@R> => {
        SExpr::List(sexprs.into_iter().map(|x| Rc::new(x)).collect::<Vec<_>>(), Some((l , r)))
    },
    <l:@L> QUOTE <sexpr:SExpr> <r:@R> => {
        let quote = Rc::new(SExpr::Atom(Atom::Symbol("quote"), Some((l , r))));
        let sexpr = Rc::new(sexpr);
        SExpr::List(vec![quote, sexpr], Some((l, r)))
    }
}

pub Program: Vec<Rc<SExpr<'input>>> = {
    <l:@L> <sexprs:SExpr*> <r:@R> => {
        sexprs.into_iter().map(|x| Rc::new(x)).collect::<Vec<_>>()
    },
}
